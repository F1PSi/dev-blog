{"author":16,"content":"Kanban-<span lang=\"en\">Boards<\/span> in JIRA bieten nur Basisfunktionalit\u00e4ten. Mit ein paar Handgriffen l\u00e4sst sich aber auch das <span lang=\"en\">Pull<\/span>-Prinzip implementieren.\n[---]\n<p>Setzt man <a href=\"https:\/\/de.wikipedia.org\/wiki\/Kanban_(Softwareentwicklung)\" target=\"_blank\">Kanban in der <span lang=\"en\">Software<\/span>entwicklung<\/a> ein, so ist eine der Praktiken das  <a href=\"https:\/\/youtu.be\/ndWPFk7GR8k\" target=\"_blank\"><span lang=\"en\">Pull<\/span>-Prinzip<\/a>. Dies bedeutet, dass sich ein Teammitglied erst ein neues Ticket in seine Spalte zieht, sobald er die Arbeit am aktuellen Ticket fertig gestellt hat. Ist er mit der Arbeit an einem Ticket fertig, so markiert er es nur als \"<span lang=\"en\">Done<\/span>\", bel\u00e4sst es aber in der gleichen Spalte. Dies soll in einem \"<span lang=\"en\">sustainable pace<\/span>\", also in einer nachhaltigen Arbeitsgeschwindigkeit, resultieren und so vor \u00dcberlastung\/<span lang=\"en\">Burn Outs<\/span> sch\u00fctzen.<\/p>\n<p>JIRA <span lang=\"en\">Software<\/span> bietet prinzipiell die M\u00f6glichkeit Kanban-<span lang=\"en\">Boards<\/span> zu erstellen, hat jedoch ein paar Defizite, was gewisse Kanban-Basisfunktionalit\u00e4ten betrifft und wo die Konkurrenz schon weiter ist. Eben eines dieser fehlenden Features ist es, ein Ticket nach der Bearbeitung schnell als \"<span lang=\"en\">Done<\/span>\" beziehungsweise \"<span lang=\"en\">Ready to Pull<\/span>\" zu markieren.<br \/>\nF\u00fcr die Kanban-<span lang=\"en\">Boards<\/span> bei karriere.at haben wir das nun auf folgende Art gel\u00f6st:<\/p>\n<h2>Custom Field f\u00fcr <span lang=\"en\">Pull<\/span>-Status<\/h2>\n<p>Zun\u00e4chst haben wir ein eigenes <span lang=\"en\">Select<\/span>-Feld \"<span lang=\"en\">Ready to Pull<\/span>\" mit den Werten \"<span lang=\"en\">Forward<\/span>\" und \"<span lang=\"en\">Back<\/span>\" erstellt und auf allen relevanten <span lang=\"en\">Screens<\/span> eingeblendet.<\/p>\n![](\/\/kcdn.at\/dev-blog\/images\/pull-prinzip-kanban-jira\/readytopull.png)\n<h2>Kartenfarben f\u00fcr Status definieren<\/h2>\n<p>Um nun visuell auf den <span lang=\"en\">Boards<\/span> anzuzeigen, ob ein Ticket bereit ist gezogen zu werden, verwenden wir die Kartenfarben, die man im <span lang=\"en\">Board<\/span> einstellen kann. Leider verhindert dies, dass man die Kartenfarben dann noch auf eine andere sinnvolle Weise verwenden kann.<\/p>\n![](\/\/kcdn.at\/dev-blog\/images\/pull-prinzip-kanban-jira\/jirakanbanboardconfig.png)\n<h2><span lang=\"en\">Transitions<\/span> definieren<\/h2>\n<p>Die hinterlegten <span lang=\"en\">Workflows<\/span> bei den Projekten sind so modifiziert, dass bei jedem Status\u00fcbergang, also dann wenn ein Benutzer auf dem <span lang=\"en\">Board<\/span> ein Ticket von einer Spalte in die n\u00e4chste zieht, das Feld \"<span lang=\"en\">Ready to Pull<\/span>\" geleert wird und der aktuelle Benutzer als \"<span lang=\"en\">Assignee<\/span>\" eingetragen wird.<\/p>\n![](\/\/kcdn.at\/dev-blog\/images\/pull-prinzip-kanban-jira\/jiratransitionpostfunctions.png)\n<h2 lang=\"en\">Scriptrunner<\/h2>\n<p>Bis hierher geht alles noch mit <span lang=\"en\">Board<\/span>mitteln. Allerdings ist das Setzen des <span lang=\"en\">Ready-to-Pull<\/span>-Felds umst\u00e4ndlich, weil der Anwender bei einem Ticket jedes Mal den <span lang=\"en\">Edit<\/span>-Dialog aufrufen muss. Das <span lang=\"en\">Add-on <a href=\"http:\/\/www.adaptavist.com\/w\/products-plugins\/adaptavist-scriptrunner\/scriptrunner-for-jira\/\" target=\"_blank\">Scriptrunner<\/a><\/span> erm\u00f6glichst es aber seit der Version 4.3 auch sogenannte <span lang=\"en\">Script Fragments<\/span> zu definieren. Im Prinzip klinkt sich das <span lang=\"en\">Plugin<\/span> mit ein paar <span lang=\"en\">Hooks<\/span> im <span lang=\"en\">Interface<\/span> ein und erm\u00f6glicht dem Administrator so die Oberfl\u00e4che an gewissen Stellen um Men\u00fcpunkte zu erweitern, die wiederum <a lang=\"en\" href=\"https:\/\/de.wikipedia.org\/wiki\/Groovy\" target=\"_blank\">Groovy-Scripts<\/a> \u00fcber einen <span lang=\"en\">Custom REST-API Endpoint<\/span> aufrufen. Eine solche Schaltfl\u00e4che haben wir implementiert um schnell den <span lang=\"en\">Ready-to-Pull<\/span>-Wert zu \u00e4ndern:<\/p>\n![](\/\/kcdn.at\/dev-blog\/images\/pull-prinzip-kanban-jira\/jiraboarddetail.png) ![](\/\/kcdn.at\/dev-blog\/images\/pull-prinzip-kanban-jira\/jiraissuedetail.png)\n<p>Die Men\u00fcpunkte werden \u00fcber ein <span lang=\"en\">Script Fragment<\/span> definiert:<\/p>\n![](\/\/kcdn.at\/dev-blog\/images\/pull-prinzip-kanban-jira\/jirawebitemscriptrunner.png)\n<p>Dieses ruft wiederum einen <span lang=\"en\">Custom Endpoint<\/span> auf, der dann den  <span lang=\"en\">Ready-to-Pull<\/span>-Wert setzt (Achtung: Es folgt ein grausliches Script):<\/p>\n\n```\nimport com.onresolve.scriptrunner.runner.rest.common.CustomEndpointDelegate\n    import groovy.json.JsonOutput\n    import groovy.transform.BaseScript\n    import javax.ws.rs.core.MultivaluedMap\n    import javax.ws.rs.core.Response\n    import com.atlassian.jira.component.ComponentAccessor\n    import com.atlassian.jira.issue.IssueManager\n    import com.atlassian.crowd.embedded.api.User\n    import com.atlassian.jira.issue.MutableIssue\n    import com.atlassian.jira.ComponentManager\n    import com.atlassian.jira.issue.ModifiedValue\n    import com.atlassian.jira.issue.util.DefaultIssueChangeHolder\n    import com.atlassian.sal.api.ApplicationProperties\n    import com.onresolve.scriptrunner.runner.rest.common.CustomEndpointDelegate\n    import com.atlassian.jira.issue.fields.CustomField\n    import com.atlassian.jira.issue.CustomFieldManager\n    import com.atlassian.jira.issue.customfields.option.Options\n    import com.atlassian.jira.issue.customfields.manager.OptionsManager\n    import com.atlassian.jira.issue.index.IssueIndexingService\n    @BaseScript CustomEndpointDelegate delegate\n    def issueManager            = ComponentAccessor.getIssueManager()\n    def customFieldManager      = ComponentAccessor.getCustomFieldManager()\n    def componentManager        = ComponentManager.getInstance()\n    def optionsManager          = componentManager.getComponentInstanceOfType(OptionsManager.class)\n    def issueIndexingService    = ComponentAccessor.getComponent(IssueIndexingService)\n    def issueService            = ComponentAccessor.getIssueService()\n    rtp(httpMethod: \"GET\") { MultivaluedMap queryParams ->\n        def issueId                 = queryParams.getFirst(\"issueId\") as Long\n        def rtpType                 = queryParams.getFirst(\"rtptype\") as String\n        def issue                   = issueManager.getIssueObject(issueId)\n        def rtpCf                   = customFieldManager.getCustomFieldObject(\"customfield_10830\")\n        def changeHolder            = new DefaultIssueChangeHolder()\n        def fieldConfig             = rtpCf.getRelevantConfig(issue)\n        def user                    = ComponentAccessor.jiraAuthenticationContext.getLoggedInUser()\n        def issueInputParameters    = issueService.newIssueInputParameters()\n        Options options             = optionsManager.getOptions(rtpCf.getConfigurationSchemes().first().getOneAndOnlyConfig());\n             \n        \/\/ set \"Ready to Pull\" to \"Forward\"\n        if (rtpType == \"forward\") {\n            def selectedOptions = options.findAll {\n                it.value == \"Forward\"\n            }.collect {\n                it.optionId.toString()\n            }\n            issueInputParameters.addCustomFieldValue(\"customfield_10830\", *selectedOptions)\n        } \/\/ end if\n        \/\/ set \"Ready to Pull\" to \"back\"\n        if (rtpType == \"back\") {\n            def selectedOptions = options.findAll {\n                it.value == \"Back\"\n            }.collect {\n                it.optionId.toString()\n            }\n            issueInputParameters.addCustomFieldValue(\"customfield_10830\", *selectedOptions)\n        } \/\/ end if\n         \n        def updateValidationResult = issueService.validateUpdate(user, issue.id, issueInputParameters)\n        if (updateValidationResult.isValid()) {\n            issueService.update(user, updateValidationResult)\n            log.debug(\"Done\")\n             \n            \/\/ reindex issue\n            issueIndexingService.reIndexIssueObjects([issue])\n             \n            \/\/ Output message to user\n            def flag = [\n                type : 'success',\n                title: \"Issue change successfully\",\n                close: 'auto',\n                body : \"The following changes have been made: Set 'Ready to Pull'.\"\n            ]\n         \n            Response.ok(JsonOutput.toJson(flag)).build()\n        } else {\n            log.debug(updateValidationResult.errorCollection)\n        }\n    }\n\n[\/code]\n<p>Ein kleiner Sch\u00f6nheitsfehler bleibt jedoch: Das  <span lang=\"en\">Board<\/span> beziehungsweise die Detailansicht eines Tickets wird nicht automatisch aktualisiert.<\/p>\n<h2>Konklusion<\/h2>\n<p>Richtig schnell w\u00e4re man, wenn man ein Ticket mittels Tastenkombination auf \" <span lang=\"en\">Done<\/span>\" setzen k\u00f6nnte. Dazu m\u00fcsste man dann aber ein eigenes  <span lang=\"en\">Plugin<\/span> bauen. Das Erweitern des Kontextmen\u00fcs bei einem Ticket w\u00e4re auch nicht schlecht, scheitert jedoch daran, dass JIRA hier nicht mal  <span lang=\"en\">Scriptrunner<\/span> eine M\u00f6glichkeit bietet sich einzuklinken. Es bleibt zu hoffen, dass  <span lang=\"en\">Atlassian<\/span> diese Basisfunktionalit\u00e4t selber mal nachliefert und somit die Kartenfarben wieder zu anderen VIsualisierungszwecken verwendet werden k\u00f6nnen. Nachdem in letzter Zeit die JIRA- <span lang=\"en\">Releases<\/span> jedoch nur kosmetischer und marketingtechnischer Natur sind d\u00fcrfte dies wohl nicht so bald geschehen.<\/p>","title":"Pull-Prinzip f\u00fcr Kanban-Boards in JIRA","slug":"pull-prinzip-kanban-jira","createDate":1462352767,"hash":"620a88613ff8fe67338f20b35488f81f","status":1}